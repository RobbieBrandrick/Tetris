<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Tetris</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
        }
    </style>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB"
        crossorigin="anonymous">
</head>

<body>

    <div class="container">
        <div class="row">
            <div class="col-lg-6">
                <canvas id="tetrisCanvas"></canvas>
            </div>
            <div class="col-lg-4" style="font-size:2em">
                <div class="row">
                    <div class="col-md-12">
                        <canvas id="nextTetrominoCanvas"></canvas>
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-12">
                        <label>Level</label>
                        <span id="level">0</span>
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-12">
                        <label>Lines</label>
                        <span id="lines">0</span>
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-12">
                        <label>Score</label>
                        <span id="score">0</span>
                    </div>
                </div>
                <div class="row" style="font-size:4em">
                    <div class="col-md-12">
                        <h1>Tetris</h1>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script type="text/javascript">

        (function () {

            //
            //Helpers
            //
            function timestamp() { return performance.now(); }
            function getById(id) { return document.getElementById(id); }
            function html(id, html) { getById(id).innerHTML = html; }

            //
            //Game Variables
            //
            var tetrisContext;
            var nextTetrominoContext;
            var currentTetromino;
            var nextTetromino;
            var score = 0;
            var lines = 0;
            var level = 10;
            var maxLevel = 18;
            var levels = [48, 43, 38, 33, 28, 23, 18, 13, 8, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 2]
            //19-28             2 (0.03s)
            // 29+             1 (0.02s)                
            var maxRows = 20;
            var maxColumns = 10;
            var maxNextColumns = 5;
            var maxNextRows = 5;
            var blockWidth = 50;
            var blockHeight = 50;
            var KEY = { LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, ESC: 27, SPACE: 32 };
            var dropTime = 0;
            var blocks = [];
            var inputs = new Array();
            var invalidate;
            var tetrominoes = {
                I: { blocks: [0x0F00, 0x2222, 0x00F0, 0x4444], color: 'cyan' },
                J: { blocks: [0x44C0, 0x8E00, 0x6440, 0x0E20], color: 'blue' },
                L: { blocks: [0x4460, 0x0E80, 0xC440, 0x2E00], color: 'orange' },
                O: { blocks: [0x0660, 0x0660, 0x0660, 0x0660], color: 'yellow' },
                S: { blocks: [0x06C0, 0x8C40, 0x6C00, 0x4620], color: 'green' },
                Z: { blocks: [0x0C60, 0x4C80, 0xC600, 0x2640], color: 'red' },
                T: { blocks: [0x0E40, 0x4C40, 0x4E00, 0x4640], color: 'purple' },
            }


            //
            //Game Logic
            //

            function run() {

                var last = timestamp();

                function gameloop() {
                    requestAnimationFrame(gameloop);

                    var now = timestamp();

                    update((now - last) / 1000);

                    draw();

                    last = now;
                }

                setupCanvas();
                registerEvents();
                getNextTetromino();
                gameloop();

            }

            function setupCanvas() {

                var tetrisCanvas = getById("tetrisCanvas");
                tetrisCanvas.height = blockHeight * maxRows;
                tetrisCanvas.width = blockWidth * maxColumns;
                tetrisContext = tetrisCanvas.getContext('2d');
                tetrisContext.translate(0.5, 0.5);

                var nextTetrominoCanvas = getById("nextTetrominoCanvas");
                nextTetrominoCanvas.height = blockHeight * maxNextRows;
                nextTetrominoCanvas.width = blockWidth * maxNextColumns;
                nextTetrominoContext = nextTetrominoCanvas.getContext('2d');
                nextTetrominoContext.translate(0.5, 0.5);

            }

            function update(time) {

                moveTetromino();

                dropTime += time;

                if (dropTime > levels[level] / 60) {
                    dropTime = 0;
                    drop()
                }

            }

            function registerEvents() {
                document.addEventListener("keydown", handleKeyDown);
            }

            function invalidate() { invalidate.gameboard = true; }
            function invalidateScore() { invalidate.score = true; }
            function invalidateNext() { invalidate.next = true; }

            function getBlocks(x, y) {

                return blocks && blocks[x] ? blocks[x][y] : null;

            }

            function setBlocks(x, y, type) {
                blocks[x] = blocks[x] || [];
                blocks[x][y] = type;
                invalidate();
            }

            function forEachBlock(tetromino, x, y, fn) {

                var row = 0;
                var column = 0
                var blocks = tetromino.blocks[tetromino.direction];
                for (var bit = 0x8000; bit > 0; bit = bit >> 1) {
                    if (blocks & bit) {
                        fn(x + column, y + row);
                    }
                    if (++column === 4) {
                        column = 0;
                        ++row;
                    }

                }
            }

            function collision(tetromino, x, y) {

                var result = false;

                forEachBlock(tetromino, x, y, function (x, y) {

                    if (x < 0 || x >= maxColumns || y >= maxRows || getBlocks(x, y)) {
                        result = true;
                    }

                })

                return result;

            }

            function handleKeyDown(event) {

                var handled = false;

                if (event.keyCode == KEY.LEFT) {
                    inputs.push(KEY.LEFT);
                    handled = true;
                } else if (event.keyCode == KEY.UP) {
                    inputs.push(KEY.UP);
                    handled = true;
                } else if (event.keyCode == KEY.RIGHT) {
                    inputs.push(KEY.RIGHT);
                    handled = true;
                } else if (event.keyCode == KEY.DOWN) {
                    inputs.push(KEY.DOWN);
                    handled = true;
                } else if (event.keyCode == KEY.SPACE) {
                    inputs.push(KEY.SPACE);
                    handled = true;
                }

                if (handled) {
                    event.preventDefault();
                }

            };

            function rotate() {

                var previousDirection = currentTetromino.direction;

                if (currentTetromino.direction == 3) {
                    currentTetromino.direction = 0;
                } else {
                    currentTetromino.direction++;
                }

                if (collision(currentTetromino, currentTetromino.x, currentTetromino.y)) {
                    currentTetromino.direction = previousDirection;
                }

                invalidate();

            }

            function move(input) {

                var x = currentTetromino.x;
                var y = currentTetromino.y;

                switch (input) {
                    case KEY.LEFT:
                        x--;
                        break;
                    case KEY.RIGHT:
                        x++;
                        break;
                    case KEY.DOWN:
                        y++;
                        break;
                    default:
                }

                if (!collision(currentTetromino, x, y)) {
                    currentTetromino.x = x;
                    currentTetromino.y = y;
                    invalidate();
                    return true;
                } else {
                    return false;
                }

            }

            function moveTetromino() {

                if (inputs.length === 0) {
                    return;
                }

                var input = inputs.pop();

                switch (input) {
                    case KEY.LEFT:
                        move(KEY.LEFT);
                        break;
                    case KEY.RIGHT:
                        move(KEY.RIGHT);
                        break;
                    case KEY.DOWN:
                        drop();
                        break;
                    case KEY.SPACE:
                        rotate();
                    default:
                }

                inputs.length = 0;

            }

            function getRandomTetromino() {

                var random = Math.floor(Math.random() * 7);
                var allTetrominoes = [tetrominoes.I, tetrominoes.J, tetrominoes.L, tetrominoes.O, tetrominoes.S, tetrominoes.Z, tetrominoes.T];
                var tetromino = allTetrominoes[random];

                var result = {
                    blocks: tetromino.blocks,
                    color: tetromino.color,
                    x: 4,
                    y: -3,
                    direction: 0,
                };

                return result;

            }

            function clearLines() {

                var numberOfLinesCleared = 0;

                for (var y = 0; y < maxRows; y++) {

                    var clearLine = true;

                    for (var x = 0; x < maxColumns; x++) {

                        if (!getBlocks(x, y)) {
                            clearLine = false;
                            break;
                        }

                    }

                    if (clearLine) {
                        numberOfLinesCleared++;
                        lines++;

                        for (var y2 = y; y2 > 0; y2--) {
                            for (var x2 = 0; x2 < maxColumns; x2++) {
                                blocks[x2][y2] = blocks[x2][y2 - 1];
                            }
                        }

                        invalidate();
                        invalidateScore();

                    }

                }

                score += numberOfLinesCleared > 0 ? 100 * Math.pow(2, numberOfLinesCleared - 1) : 0;

                if (lines / 10 >= level + 1) {
                    level++;
                }


            }

            function getNextTetromino() {

                currentTetromino = nextTetromino || getRandomTetromino();
                nextTetromino = getRandomTetromino();
                invalidateNext();

            }

            function reset() {

                score = 0;
                lines = 0;
                level = 0;
                blocks = [];

                invalidate();
                invalidateScore();
                invalidateNext();
                getNextTetromino();

            }

            function gameOver() {

                var isGameOver = false;

                for (var x = 0; x < maxColumns; x++) {

                    if (getBlocks(x, 0)) {
                        isGameOver = true;
                        break;
                    }

                }

                return isGameOver;

            }

            function drop() {

                var isMoved = move(KEY.DOWN);

                if (!isMoved) {

                    forEachBlock(currentTetromino, currentTetromino.x, currentTetromino.y, function (x, y) {
                        setBlocks(x, y, currentTetromino)
                    })

                    getNextTetromino();

                    clearLines();

                    if (gameOver()) {
                        reset();
                    }

                    invalidate();
                    
                }

            }

            //
            //Render
            //
            function drawGameboard() {
                if (!invalidate.gameboard) {
                    return;
                }

                tetrisContext.clearRect(-1, -1, maxColumns * blockWidth + 1, maxRows * blockHeight + 1);

                drawExistingTetrominos();

                drawTetromino();

                invalidate.gameboard = false;

            }

            function drawScore() {

                if (!invalidate.score) {
                    return;
                }

                html("score", score);
                html("lines", lines);
                html("level", level);

                invalidate.score = false;

            }

            function drawNextTetromino() {
                if (!invalidate.next) {
                    return;
                }

                nextTetrominoContext.clearRect(-1, -1, blockWidth * maxNextColumns + 1, blockHeight * maxNextRows + 1);

                forEachBlock(nextTetromino, 0.5, 0.5, function (x, y) {
                    drawBlock(nextTetrominoContext, x, y, nextTetromino.color);
                })

                invalidate.next = false;
            }


            function draw() {

                drawGameboard();
                drawScore();
                drawNextTetromino();

            }

            function drawBlock(ctx, x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x * blockWidth, y * blockWidth, blockWidth, blockHeight);
                ctx.fill();
            }

            function drawExistingTetrominos() {
                var block;

                for (var x = 0; x < maxColumns; x++) {

                    for (var y = 0; y < maxRows; y++) {

                        if (block = getBlocks(x, y)){
                            drawBlock(tetrisContext, x, y, block.color);

                        }

                    }

                }

            }

            function drawTetromino() {
                forEachBlock(currentTetromino, currentTetromino.x, currentTetromino.y, function (x, y) {
                    drawBlock(tetrisContext, x, y, currentTetromino.color);
                })
            }

            //
            //Its Run Time
            //
            run();
        })();

    </script>

</body>

</html>